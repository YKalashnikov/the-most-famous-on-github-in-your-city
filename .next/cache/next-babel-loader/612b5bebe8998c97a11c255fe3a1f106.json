{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\n\n/* eslint-disable import/prefer-default-export */\nimport { LOADING, LOAD_MOST_POPULAR_USERS, ERROR_WHILE_FETCHING_INITIAL_TABLE, CITY_TO_SEARCH, SNACKBAR_STATUS } from './types';\nimport axios from 'axios';\n\nvar pick = require('lodash.pick');\n\nvar map = require('lodash.map');\n\nvar partialRight = require('lodash.partialright');\n\nvar headers = {\n  'Content-Type': 'application/json'\n};\nexport var handleSnackBarStatus = function handleSnackBarStatus(bool) {\n  return {\n    type: SNACKBAR_STATUS,\n    payload: bool\n  };\n};\n\nvar getEachUserGivenId = function getEachUserGivenId(id, index) {\n  return new _Promise(function (resolve, reject) {\n    axios.all([axios.get(\"https://api.github.com/users/\".concat(id)), axios.get(\"https://api.github.com/users/\".concat(id, \"/repos?per_page=200\"))]).then(axios.spread(function (userProfile, userRepo) {\n      var userProfileData = userProfile.data;\n      var totalUserStars = userRepo.data.map(function (i) {\n        return i.stargazers_count;\n      }).reduce(function (total, item) {\n        return total + item;\n      });\n      var result = pick(userProfileData, ['login', 'bio', 'email', 'name', 'id']);\n\n      var modifiedResult = _Object$assign(result, {\n        totalUserStars: totalUserStars\n      });\n\n      if (result && _Object$entries(modifiedResult).length !== 0 && result.constructor === Object) {\n        resolve(modifiedResult);\n      } else {\n        reject(new Error('No data received'));\n      }\n    }))[\"catch\"](function (err) {\n      console.log('HIT the ERROR');\n    });\n  });\n}; // Util function to merge to topUsers array the data from userProfiles array, as they are coming from two different api calls\n\n\nvar mergeArraysConditionally = function mergeArraysConditionally(topUsers, userProfiles) {\n  var merged = []; // First return the first array with only elements whose id matches with an element's id from the second array\n\n  topUsers.every(function (i) {\n    return userProfiles.map(function (j) {\n      return j.id;\n    }).includes(i.id) ? merged.push(i) : null;\n  }); // Now that I have got two separate arrays of matched and the original array, simply merge the matched array (on the basis of ID) with the original array containing the data.\n\n  merged = merged.map(function (i) {\n    return _Object$assign(i, userProfiles.find(function (j) {\n      return j.id === i.id;\n    }));\n  });\n  return merged;\n};\n\nexport var loadMostPopularUsers = function loadMostPopularUsers(city, page, numbersToFetch) {\n  return function _callee2(dispatch) {\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            try {\n              dispatch({\n                type: LOADING,\n                payload: true\n              });\n              axios({\n                method: 'get',\n                // url: `https://api.github.com/search/users?q=location%3A${city}&followers%3A%3E%3D1000&ref=searchresults&s=followers&type=Users`,\n                url: \"https://api.github.com/search/users?q=location:\".concat(city),\n                headers: headers\n              }).then(function _callee(res) {\n                var totalNoOfUsersFromAPI, start, end, resData, topTenUsersInCity, userIds, topTenUserProfiles, topUserIndividualProfiles;\n                return _regeneratorRuntime.async(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        totalNoOfUsersFromAPI = res.data.items.length;\n                        start = page * numbersToFetch;\n                        end = start + numbersToFetch;\n                        resData = res.data.items.slice(start, end);\n                        topTenUsersInCity = map(resData, partialRight(pick, ['login', 'id', 'avatar_url']));\n                        userIds = topTenUsersInCity.map(function (i) {\n                          return i.login;\n                        });\n                        _context.next = 8;\n                        return _regeneratorRuntime.awrap(userIds.map(getEachUserGivenId));\n\n                      case 8:\n                        topTenUserProfiles = _context.sent;\n                        topUserIndividualProfiles = _Promise.all(topTenUserProfiles);\n                        topUserIndividualProfiles.then(function (res) {\n                          dispatch({\n                            type: LOAD_MOST_POPULAR_USERS,\n                            payload: {\n                              topTenUsersInCity: mergeArraysConditionally(topTenUsersInCity, res),\n                              totalNoOfUsersFromAPI: totalNoOfUsersFromAPI\n                            }\n                          });\n                        })[\"catch\"](function (err) {\n                          dispatch({\n                            type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n                            payload: 'Error occurred while loading Initial Data'\n                          });\n                        });\n\n                      case 11:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                });\n              })[\"catch\"](function (err) {\n                dispatch({\n                  type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n                  payload: 'Error occurred while loading Initial Data'\n                });\n              });\n            } catch (err) {\n              dispatch({\n                type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n                payload: 'Error occurred while loading Initial Data'\n              });\n            }\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  };\n};\nexport var handleCityToSearchChange = function handleCityToSearchChange(city) {\n  return {\n    type: CITY_TO_SEARCH,\n    payload: city\n  };\n};","map":{"version":3,"sources":["/Users/yuriikalashnikov/Desktop/popular-user-in-github/actions/getUserActions.js"],"names":["LOADING","LOAD_MOST_POPULAR_USERS","ERROR_WHILE_FETCHING_INITIAL_TABLE","CITY_TO_SEARCH","SNACKBAR_STATUS","axios","pick","require","map","partialRight","headers","handleSnackBarStatus","bool","type","payload","getEachUserGivenId","id","index","resolve","reject","all","get","then","spread","userProfile","userRepo","userProfileData","data","totalUserStars","i","stargazers_count","reduce","total","item","result","modifiedResult","length","constructor","Object","Error","err","console","log","mergeArraysConditionally","topUsers","userProfiles","merged","every","j","includes","push","find","loadMostPopularUsers","city","page","numbersToFetch","dispatch","method","url","res","totalNoOfUsersFromAPI","items","start","end","resData","slice","topTenUsersInCity","userIds","login","topTenUserProfiles","topUserIndividualProfiles","handleCityToSearchChange"],"mappings":"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","sourcesContent":["/* eslint-disable import/prefer-default-export */\nimport {\n    LOADING,\n    LOAD_MOST_POPULAR_USERS,\n    ERROR_WHILE_FETCHING_INITIAL_TABLE,\n    CITY_TO_SEARCH,\n    SNACKBAR_STATUS,\n  } from './types'\n  \n  import axios from 'axios'\n  const pick = require('lodash.pick')\n  const map = require('lodash.map')\n  const partialRight = require('lodash.partialright')\n  \n  const headers = {\n    'Content-Type': 'application/json',\n  }\n  \n  export const handleSnackBarStatus = bool => {\n    return {\n      type: SNACKBAR_STATUS,\n      payload: bool,\n    }\n  }\n  \n  const getEachUserGivenId = (id, index) => {\n    return new Promise((resolve, reject) => {\n      axios\n        .all([\n          axios.get(`https://api.github.com/users/${id}`),\n          axios.get(`https://api.github.com/users/${id}/repos?per_page=200`),\n        ])\n        .then(\n          axios.spread((userProfile, userRepo) => {\n            let userProfileData = userProfile.data\n            const totalUserStars = userRepo.data\n              .map(i => i.stargazers_count)\n              .reduce((total, item) => total + item)\n            let result = pick(userProfileData, [\n              'login',\n              'bio',\n              'email',\n              'name',\n              'id',\n            ])\n            let modifiedResult = Object.assign(result, {\n              totalUserStars: totalUserStars,\n            })\n            if (\n              result &&\n              Object.entries(modifiedResult).length !== 0 &&\n              result.constructor === Object\n            ) {\n              resolve(modifiedResult)\n            } else {\n              reject(new Error('No data received'))\n            }\n          }),\n        )\n        .catch(err => {\n          console.log('HIT the ERROR')\n        })\n    })\n  }\n  \n  // Util function to merge to topUsers array the data from userProfiles array, as they are coming from two different api calls\n  const mergeArraysConditionally = (topUsers, userProfiles) => {\n    let merged = []\n  \n    // First return the first array with only elements whose id matches with an element's id from the second array\n    topUsers.every(i =>\n      userProfiles.map(j => j.id).includes(i.id) ? merged.push(i) : null,\n    )\n  \n    // Now that I have got two separate arrays of matched and the original array, simply merge the matched array (on the basis of ID) with the original array containing the data.\n    merged = merged.map(i =>\n      Object.assign(\n        i,\n        userProfiles.find(j => j.id === i.id),\n      ),\n    )\n    return merged\n  }\n  \n  export const loadMostPopularUsers = (\n    city,\n    page,\n    numbersToFetch,\n  ) => async dispatch => {\n    try {\n      dispatch({\n        type: LOADING,\n        payload: true,\n      })\n      axios({\n        method: 'get',\n        // url: `https://api.github.com/search/users?q=location%3A${city}&followers%3A%3E%3D1000&ref=searchresults&s=followers&type=Users`,\n        url: `https://api.github.com/search/users?q=location:${city}`,\n        headers,\n      })\n        .then(async res => {\n          const totalNoOfUsersFromAPI = res.data.items.length\n          const start = page * numbersToFetch\n          const end = start + numbersToFetch\n          const resData = res.data.items.slice(start, end)\n          var topTenUsersInCity = map(\n            resData,\n            partialRight(pick, ['login', 'id', 'avatar_url']),\n          )\n  \n          const userIds = topTenUsersInCity.map(i => i.login)\n          let topTenUserProfiles = await userIds.map(getEachUserGivenId)\n          let topUserIndividualProfiles = Promise.all(topTenUserProfiles)\n          topUserIndividualProfiles\n            .then(res => {\n              dispatch({\n                type: LOAD_MOST_POPULAR_USERS,\n                payload: {\n                  topTenUsersInCity: mergeArraysConditionally(\n                    topTenUsersInCity,\n                    res,\n                  ),\n                  totalNoOfUsersFromAPI,\n                },\n              })\n            })\n            .catch(err => {\n              dispatch({\n                type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n                payload: 'Error occurred while loading Initial Data',\n              })\n            })\n        })\n        .catch(err => {\n          dispatch({\n            type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n            payload: 'Error occurred while loading Initial Data',\n          })\n        })\n    } catch (err) {\n      dispatch({\n        type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n        payload: 'Error occurred while loading Initial Data',\n      })\n    }\n  }\n  \n  export const handleCityToSearchChange = city => {\n    return {\n      type: CITY_TO_SEARCH,\n      payload: city,\n    }\n  }\n  "]},"metadata":{},"sourceType":"module"}