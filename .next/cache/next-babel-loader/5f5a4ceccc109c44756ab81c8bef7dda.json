{"ast":null,"code":"/* eslint-disable import/prefer-default-export */\nimport { LOADING, LOAD_MOST_POPULAR_USERS, ERROR_WHILE_FETCHING_INITIAL_TABLE, CITY_TO_SEARCH, SNACKBAR_STATUS } from './types';\nimport axios from 'axios';\n\nconst pick = require('lodash.pick');\n\nconst map = require('lodash.map');\n\nconst partialRight = require('lodash.partialright');\n\nconst headers = {\n  'Content-Type': 'application/json'\n};\nexport const handleSnackBarStatus = bool => {\n  return {\n    type: SNACKBAR_STATUS,\n    payload: bool\n  };\n};\n\nconst getEachUserGivenId = (id, index) => {\n  return new Promise((resolve, reject) => {\n    axios.all([axios.get(`https://api.github.com/users/${id}`), axios.get(`https://api.github.com/users/${id}/repos?per_page=200`)]).then(axios.spread((userProfile, userRepo) => {\n      let userProfileData = userProfile.data;\n      const totalUserStars = userRepo.data.map(i => i.stargazers_count).reduce((total, item) => total + item);\n      let result = pick(userProfileData, ['login', 'bio', 'email', 'name', 'id']);\n      let modifiedResult = Object.assign(result, {\n        totalUserStars: totalUserStars\n      });\n\n      if (result && Object.entries(modifiedResult).length !== 0 && result.constructor === Object) {\n        resolve(modifiedResult);\n      } else {\n        reject(new Error('No data received'));\n      }\n    })).catch(err => {\n      console.log('HIT the ERROR');\n    });\n  });\n}; // Util function to merge to topUsers array the data from userProfiles array, as they are coming from two different api calls\n\n\nconst mergeArraysConditionally = (topUsers, userProfiles) => {\n  let merged = []; // First return the first array with only elements whose id matches with an element's id from the second array\n\n  topUsers.every(i => userProfiles.map(j => j.id).includes(i.id) ? merged.push(i) : null); // Now that I have got two separate arrays of matched and the original array, simply merge the matched array (on the basis of ID) with the original array containing the data.\n\n  merged = merged.map(i => Object.assign(i, userProfiles.find(j => j.id === i.id)));\n  return merged;\n};\n\nexport const loadMostPopularUsers = (city, page, numbersToFetch) => async dispatch => {\n  try {\n    dispatch({\n      type: LOADING,\n      payload: true\n    });\n    axios({\n      method: 'get',\n      // url: `https://api.github.com/search/users?q=location%3A${city}&followers%3A%3E%3D1000&ref=searchresults&s=followers&type=Users`,\n      url: `https://api.github.com/search/users?q=location:${city}`,\n      headers\n    }).then(async res => {\n      const totalNoOfUsersFromAPI = res.data.items.length;\n      const start = page * numbersToFetch;\n      const end = start + numbersToFetch;\n      const resData = res.data.items.slice(start, end);\n      var topTenUsersInCity = map(resData, partialRight(pick, ['login', 'id', 'avatar_url']));\n      const userIds = topTenUsersInCity.map(i => i.login);\n      let topTenUserProfiles = await userIds.map(getEachUserGivenId);\n      let topUserIndividualProfiles = Promise.all(topTenUserProfiles);\n      topUserIndividualProfiles.then(res => {\n        dispatch({\n          type: LOAD_MOST_POPULAR_USERS,\n          payload: {\n            topTenUsersInCity: mergeArraysConditionally(topTenUsersInCity, res),\n            totalNoOfUsersFromAPI\n          }\n        });\n      }).catch(err => {\n        dispatch({\n          type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n          payload: 'Error occurred while loading Initial Data'\n        });\n      });\n    }).catch(err => {\n      dispatch({\n        type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n        payload: 'Error occurred while loading Initial Data'\n      });\n    });\n  } catch (err) {\n    dispatch({\n      type: ERROR_WHILE_FETCHING_INITIAL_TABLE,\n      payload: 'Error occurred while loading Initial Data'\n    });\n  }\n};\nexport const handleCityToSearchChange = city => {\n  return {\n    type: CITY_TO_SEARCH,\n    payload: city\n  };\n};","map":null,"metadata":{},"sourceType":"module"}